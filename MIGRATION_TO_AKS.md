# Azure Day 2 Engine - Migraci√≥n a AKS con Helm

Gu√≠a completa paso a paso para migrar Azure Day 2 Engine a Azure Kubernetes Service (AKS) usando Helm Charts con servicios separados para backend y frontend.

## üìã Arquitectura de la Migraci√≥n

La migraci√≥n separa el proyecto en dos componentes independientes:

### Backend (API)
- **Puerto**: 8000
- **Imagen**: `${ACR_NAME}.azurecr.io/azure-day2-engine-backend:${TAG}`
- **R√©plicas**: 1 (optimizado para recursos)
- **Servicio**: ClusterIP (interno)
- **Recursos**: 256Mi RAM, 250m CPU (request) / 512Mi RAM, 500m CPU (limit)

### Frontend (Dashboard)
- **Puerto**: 8501
- **Imagen**: `${ACR_NAME}.azurecr.io/azure-day2-engine-frontend:${TAG}`
- **R√©plicas**: 1 (demo/presentaci√≥n)
- **Servicio**: LoadBalancer (acceso externo)
- **Recursos**: 128Mi RAM, 100m CPU (request) / 256Mi RAM, 200m CPU (limit)

## üéØ Prerequisitos

### 1. Azure Resources
- **AKS Cluster**: `adv_aks` en el resource group especificado
- **Azure Container Registry**: `advaks` (o configurar ACR_NAME)
- **Azure CLI**: Instalado y configurado (`az --version`)
- **kubectl**: Instalado y configurado (`kubectl version`)

### 2. Helm Installation
Instalar Helm v3:
```bash
# Para macOS
brew install helm

# Para Linux
curl https://get.helm.sh/helm-v3.12.3-linux-amd64.tar.gz | tar xz
sudo mv linux-amd64/helm /usr/local/bin/helm

# Verificar instalaci√≥n
helm version
```

### 3. Credenciales Azure
Configurar las siguientes variables de entorno:
```bash
export AZURE_CLIENT_ID="your-client-id"
export AZURE_TENANT_ID="your-tenant-id"
export AZURE_CLIENT_SECRET="your-client-secret"
export AZURE_SUBSCRIPTION_ID="your-subscription-id"
```

### 4. Configuraci√≥n AKS y Helm
```bash
export ACR_NAME="advaks"                         # Nombre de tu ACR
export AKS_CLUSTER="adv_aks"                    # Nombre de tu cluster AKS
export AKS_RESOURCE_GROUP="your-rg-name"        # Resource group de AKS
export IMAGE_TAG="latest"                        # Tag de las im√°genes
export NAMESPACE="default"                       # Kubernetes namespace
export HELM_RELEASE_NAME="azure-day2-engine"    # Nombre del release de Helm
```

## üöÄ Proceso de Migraci√≥n

### Paso 1: Preparar el Entorno

```bash
# 1. Clonar o actualizar el repositorio
cd ~/Desarrollo/azure-day2-engine-python

# 2. Verificar estructura del proyecto
ls -la
# Deber√≠as ver: docker/, kubernetes/, helm-chart/, scripts/, app/, frontend/

# 3. Configurar variables de entorno
export ACR_NAME="advaks"
export AKS_CLUSTER="adv_aks"
export AKS_RESOURCE_GROUP="tu-resource-group"
export IMAGE_TAG="v1.0.0"

# 4. Verificar conectividad Azure
az account show
az acr list --query "[].{Name:name,LoginServer:loginServer}" -o table
```

### Paso 2: Construir y Subir Im√°genes Docker

```bash
# 1. Ejecutar el script de build y push
./scripts/build-and-push.sh

# El script ejecutar√°:
# - Verificaci√≥n de prerequisitos
# - Login a ACR
# - Build de imagen backend
# - Build de imagen frontend  
# - Push de ambas im√°genes
# - Verificaci√≥n en registry
```

**Salida esperada:**
```
üèóÔ∏è Azure Day 2 Engine - Docker Build and Push
==================================================
‚úÖ Prerequisites verified
‚úÖ Logged in to ACR: advaks
‚úÖ Backend image built: advaks.azurecr.io/azure-day2-engine-backend:latest
‚úÖ Frontend image built: advaks.azurecr.io/azure-day2-engine-frontend:latest
‚úÖ Backend image pushed to registry
‚úÖ Frontend image pushed to registry
‚úÖ Build and push completed successfully!
```

### Paso 3: Desplegar a AKS con Helm

```bash
# 1. Ejecutar el script de deployment con Helm
./scripts/deploy-to-aks.sh

# El script ejecutar√°:
# - Verificaci√≥n de prerequisitos (kubectl, Helm, Azure CLI)
# - Configuraci√≥n de kubectl con AKS
# - Creaci√≥n/verificaci√≥n del namespace
# - Preparaci√≥n de valores de Helm
# - Instalaci√≥n/actualizaci√≥n del Helm chart
# - Verificaci√≥n de deployments
```

**Salida esperada:**
```
üöÄ Azure Day 2 Engine - AKS Deployment (Helm)
==============================================
‚úÖ Prerequisites verified
‚úÖ AKS credentials configured
‚úÖ Connected to AKS cluster: adv_aks
‚úÖ Namespace 'default' ready
‚úÖ Azure credentials configured for Helm deployment
‚úÖ Helm release installed successfully
‚úÖ All deployments are ready!
```

### Paso 4: Verificar el Despliegue

```bash
# 1. Verificar el release de Helm
helm list -n default

# 2. Ver status detallado del release
helm status azure-day2-engine -n default

# 3. Verificar pods
kubectl get pods -l app.kubernetes.io/name=azure-day2-engine

# 4. Verificar servicios
kubectl get services -l app.kubernetes.io/name=azure-day2-engine

# 5. Verificar deployments
kubectl get deployments -l app.kubernetes.io/name=azure-day2-engine

# 6. Obtener IP externa del frontend
kubectl get service azure-day2-engine-frontend-service

# 7. Ver logs del backend
kubectl logs -l app.kubernetes.io/name=azure-day2-engine,component=backend

# 8. Ver logs del frontend
kubectl logs -l app.kubernetes.io/name=azure-day2-engine,component=frontend
```

### Paso 5: Probar la Aplicaci√≥n

```bash
# 1. Test de salud del backend (port-forward temporal)
kubectl port-forward service/azure-day2-engine-backend-service 8080:80 &
curl http://localhost:8080/health

# 2. Acceder al frontend via IP externa
# Esperar a que se asigne la IP externa (puede tomar 2-5 minutos)
kubectl get service azure-day2-engine-frontend-service -w

# 3. Una vez asignada, acceder via navegador
# http://<EXTERNAL-IP>/
```

## üõ†Ô∏è Configuraci√≥n Avanzada con Helm

### Personalizar Valores de Helm

Crear un archivo `custom-values.yaml` para personalizaci√≥n:

```yaml
# custom-values.yaml
backend:
  replicaCount: 2  # Cambiar a m√°s r√©plicas si es necesario
  resources:
    requests:
      memory: "512Mi"
      cpu: "500m"
    limits:
      memory: "1Gi"
      cpu: "1000m"

frontend:
  replicaCount: 1
  service:
    type: LoadBalancer  # o NodePort, ClusterIP

global:
  registry: "your-acr.azurecr.io"
  imageTag: "v1.0.0"
  azure:
    clientId: "your-real-client-id"
    tenantId: "your-real-tenant-id"
    clientSecret: "your-real-secret"
    subscriptionId: "your-real-subscription"
```

Aplicar la configuraci√≥n personalizada:
```bash
helm upgrade azure-day2-engine ./helm-chart -n default -f custom-values.yaml
```

### Scaling con Helm

```bash
# Escalar backend usando Helm
helm upgrade azure-day2-engine ./helm-chart -n default \
  --set backend.replicaCount=3

# Actualizar recursos usando Helm
helm upgrade azure-day2-engine ./helm-chart -n default \
  --set backend.resources.requests.cpu=500m \
  --set backend.resources.limits.memory=1Gi

# Configurar auto-scaling (despu√©s del deployment)
kubectl autoscale deployment azure-day2-engine-backend --cpu-percent=70 --min=1 --max=5
```

### Monitoreo y Logging con Helm

```bash
# Ver status del Helm release
helm status azure-day2-engine -n default

# Ver historial de releases
helm history azure-day2-engine -n default

# Ver logs en tiempo real
kubectl logs -f deployment/azure-day2-engine-backend

# Describir pod para troubleshooting
kubectl describe pod <pod-name>

# Verificar events del namespace
kubectl events --sort-by=.metadata.creationTimestamp

# Usar el script de operaciones
./scripts/aks-operations.sh status
./scripts/aks-operations.sh logs
./scripts/aks-operations.sh helm-status
```

## üîß Troubleshooting

### Problemas Comunes

#### 1. ImagePullBackOff
```bash
# Verificar que las im√°genes existen en ACR
az acr repository list --name $ACR_NAME

# Verificar permisos de AKS en ACR
az aks check-acr --resource-group $AKS_RESOURCE_GROUP --name $AKS_CLUSTER --acr $ACR_NAME.azurecr.io
```

#### 2. Backend no responde
```bash
# Verificar configuraci√≥n de secrets
kubectl get secret azure-credentials -o yaml

# Verificar variables de entorno en pods
kubectl exec deployment/azure-day2-engine-backend -- env | grep AZURE

# Verificar logs detallados
kubectl logs deployment/azure-day2-engine-backend --previous
```

#### 3. Frontend no accesible
```bash
# Verificar estado del LoadBalancer
kubectl describe service azure-day2-engine-frontend-service

# Verificar si el frontend puede conectar al backend
kubectl exec deployment/azure-day2-engine-frontend -- curl -I azure-day2-engine-backend-service
```

#### 4. Problemas de Azure Credentials
```bash
# Actualizar credenciales usando Helm upgrade
helm upgrade azure-day2-engine ./helm-chart -n default \
  --set global.azure.clientId=$AZURE_CLIENT_ID \
  --set global.azure.tenantId=$AZURE_TENANT_ID \
  --set global.azure.clientSecret=$AZURE_CLIENT_SECRET \
  --set global.azure.subscriptionId=$AZURE_SUBSCRIPTION_ID

# O usar el script de operaciones
export AZURE_CLIENT_ID="new-client-id"
export AZURE_TENANT_ID="new-tenant-id" 
export AZURE_CLIENT_SECRET="new-client-secret"
export AZURE_SUBSCRIPTION_ID="new-subscription-id"
./scripts/aks-operations.sh update-secrets
```

#### 5. Problemas con Helm
```bash
# Ver releases de Helm
helm list -n default

# Ver status detallado
helm status azure-day2-engine -n default

# Ver historial de cambios
helm history azure-day2-engine -n default

# Rollback a una versi√≥n anterior
helm rollback azure-day2-engine 1 -n default

# Verificar sintaxis del chart
helm lint ./helm-chart

# Debug del template
helm template azure-day2-engine ./helm-chart --debug
```

## üßπ Limpieza y Rollback con Helm

### Limpiar Deployment Completo
```bash
# Ejecutar script de limpieza (usa Helm uninstall)
./scripts/cleanup-deployment.sh

# O manualmente con Helm
helm uninstall azure-day2-engine -n default

# Verificar que se elimin√≥ todo
kubectl get all -l app.kubernetes.io/name=azure-day2-engine
```

### Rollback a Versi√≥n Anterior con Helm
```bash
# Ver historial de releases de Helm
helm history azure-day2-engine -n default

# Rollback a la versi√≥n anterior
helm rollback azure-day2-engine -n default

# Rollback a una versi√≥n espec√≠fica
helm rollback azure-day2-engine 2 -n default

# Verificar el rollback
helm status azure-day2-engine -n default
```

## üìä Configuraci√≥n de Producci√≥n

### Recursos Recomendados para Producci√≥n

```yaml
# Backend - Producci√≥n
resources:
  requests:
    memory: "512Mi"
    cpu: "500m"
  limits:
    memory: "1Gi"
    cpu: "1000m"

# Frontend - Producci√≥n
resources:
  requests:
    memory: "256Mi"
    cpu: "200m"
  limits:
    memory: "512Mi"
    cpu: "400m"
```

### Configuraci√≥n de Auto-scaling
```bash
# HPA para backend
kubectl autoscale deployment azure-day2-engine-backend \
  --cpu-percent=70 --min=2 --max=10

# Verificar HPA
kubectl get hpa
```

### Backup de Configuraci√≥n
```bash
# Exportar configuraci√≥n actual
kubectl get all,secrets,configmaps -l app=azure-day2-engine -o yaml > azure-day2-engine-backup.yaml
```

## üîê Seguridad

### Network Policies (Opcional)
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: azure-day2-engine-netpol
spec:
  podSelector:
    matchLabels:
      app: azure-day2-engine
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: azure-day2-engine
  egress:
  - to: []
```

### Pod Security Context
Los Dockerfiles ya incluyen usuarios no-root. Para mayor seguridad:

```yaml
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000
```

## üìà Resultados Esperados

### URLs de Acceso
- **Frontend Dashboard**: `http://<EXTERNAL-IP>/`
- **Backend API Docs**: Port-forward a `http://localhost:8080/docs`
- **Health Check**: Port-forward a `http://localhost:8080/health`

### Estructura Final en AKS con Helm
```
azure-day2-engine/ (Helm Release)
‚îú‚îÄ‚îÄ Backend Deployment (1 replica - optimizado)
‚îÇ   ‚îî‚îÄ‚îÄ Pod 1: backend-xxx-aaa
‚îú‚îÄ‚îÄ Frontend Deployment (1 replica)
‚îÇ   ‚îî‚îÄ‚îÄ Pod 1: frontend-xxx-ccc
‚îú‚îÄ‚îÄ Services
‚îÇ   ‚îú‚îÄ‚îÄ backend-service (ClusterIP)
‚îÇ   ‚îî‚îÄ‚îÄ frontend-service (LoadBalancer)
‚îú‚îÄ‚îÄ Helm Management
‚îÇ   ‚îú‚îÄ‚îÄ Release: azure-day2-engine
‚îÇ   ‚îú‚îÄ‚îÄ Chart Version: 1.0.0
‚îÇ   ‚îî‚îÄ‚îÄ Values: Configurables via upgrade
‚îî‚îÄ‚îÄ Resources
    ‚îú‚îÄ‚îÄ ServiceAccount
    ‚îú‚îÄ‚îÄ Secret (Azure credentials)
    ‚îî‚îÄ‚îÄ ConfigMap (SQL scripts)
```

## üéâ ¬°Migraci√≥n Completada con Helm!

Tu Azure Day 2 Engine ahora est√° ejecut√°ndose en AKS con Helm:
- ‚úÖ Backend API optimizado (1 r√©plica configurable)
- ‚úÖ Frontend dashboard accesible externamente
- ‚úÖ Gesti√≥n simplificada con Helm Charts
- ‚úÖ Configuraci√≥n versionada y reproducible
- ‚úÖ Actualizaciones y rollbacks sencillos
- ‚úÖ Servicios separados y escalables independientemente
- ‚úÖ Scripts de mantenimiento actualizados para Helm
- ‚úÖ Monitoreo y logging configurado

**Ventajas de usar Helm:**
- Gesti√≥n de configuraci√≥n centralizada
- Versionado de deployments
- Rollbacks autom√°ticos
- Plantillas reutilizables
- Actualizaciones incrementales

El backend es el componente de valor con las APIs, mientras que el frontend sirve como herramienta de demostraci√≥n y pruebas.