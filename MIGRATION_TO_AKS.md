# Azure Day 2 Engine - Migraci√≥n a AKS con Helm

Gu√≠a completa paso a paso para migrar Azure Day 2 Engine a Azure Kubernetes Service (AKS) usando Helm Charts con servicios separados para backend y frontend.

## üìã Arquitectura de la Migraci√≥n

La migraci√≥n separa el proyecto en dos componentes independientes:

### Backend (API)
- **Puerto**: 8000
- **Imagen**: `${ACR_NAME}.azurecr.io/azure-day2-engine-backend:${TAG}`
- **R√©plicas**: 1 (optimizado para recursos)
- **Servicio**: ClusterIP (interno)
- **Recursos**: 256Mi RAM, 250m CPU (request) / 512Mi RAM, 500m CPU (limit)

### Frontend (Dashboard)
- **Puerto**: 8501
- **Imagen**: `${ACR_NAME}.azurecr.io/azure-day2-engine-frontend:${TAG}`
- **R√©plicas**: 1 (demo/presentaci√≥n)
- **Servicio**: LoadBalancer (acceso externo)
- **Recursos**: 128Mi RAM, 100m CPU (request) / 256Mi RAM, 200m CPU (limit)

## üéØ Prerequisitos

### 1. Azure Resources
- **AKS Cluster**: `adv_aks` en el resource group especificado
- **Azure Container Registry**: `advaks` (o configurar ACR_NAME)
- **Azure CLI**: Instalado y configurado (`az --version`)
- **kubectl**: Instalado y configurado (`kubectl version`)

### 2. Helm Installation
Instalar Helm v3:
```bash
# Para macOS
brew install helm

# Para Linux
curl https://get.helm.sh/helm-v3.12.3-linux-amd64.tar.gz | tar xz
sudo mv linux-amd64/helm /usr/local/bin/helm

# Verificar instalaci√≥n
helm version
```

### 3. Configuraci√≥n de Variables de Entorno (Centralizada)

El proyecto ahora utiliza un sistema centralizado de configuraci√≥n mediante archivos `.env`:

#### Opci√≥n 1: Configuraci√≥n Interactiva (Recomendada)
```bash
# Ejecutar el asistente de configuraci√≥n
./scripts/setup-env.sh
```

Este script te guiar√° paso a paso para configurar todas las variables necesarias.

#### Opci√≥n 2: Configuraci√≥n Manual
```bash
# Copiar el template de configuraci√≥n
cp .env.example .env

# Editar el archivo .env con tus valores reales
nano .env  # o usa tu editor preferido
```

**Variables requeridas en `.env`:**
```bash
# Azure Configuration
AZURE_TENANT_ID=your-tenant-id-here
AZURE_CLIENT_ID=your-client-id-here
AZURE_CLIENT_SECRET=your-client-secret-here
AZURE_SUBSCRIPTION_ID=your-subscription-id-here

# AKS and Container Registry Configuration
ACR_NAME=advaks
AKS_CLUSTER=adv_aks
AKS_RESOURCE_GROUP=your-resource-group-here
IMAGE_TAG=latest
NAMESPACE=default
HELM_RELEASE_NAME=azure-day2-engine
```

#### Validaci√≥n Autom√°tica
```bash
# Verificar configuraci√≥n (opcional)
source scripts/load-env.sh
```

**Ventajas del sistema centralizado:**
- ‚úÖ **√önica fuente de verdad**: Todas las variables en un solo archivo
- ‚úÖ **Validaci√≥n autom√°tica**: Los scripts verifican autom√°ticamente las configuraciones
- ‚úÖ **Seguridad mejorada**: Las credenciales se muestran enmascaradas
- ‚úÖ **Sin exports manuales**: No necesitas configurar variables de entorno manualmente
- ‚úÖ **Consistencia**: Todos los scripts usan la misma configuraci√≥n

## üöÄ Proceso de Migraci√≥n

### Paso 1: Preparar el Entorno

```bash
# 1. Clonar o actualizar el repositorio
cd ~/Desarrollo/azure-day2-engine-python

# 2. Verificar estructura del proyecto
ls -la
# Deber√≠as ver: docker/, helm-chart/, scripts/, app/, frontend/

# 3. Configurar variables de entorno (NUEVO - Sistema Centralizado)
# Opci√≥n A: Configuraci√≥n interactiva (recomendada)
./scripts/setup-env.sh

# Opci√≥n B: Configuraci√≥n manual
cp .env.example .env
# Editar .env con tus valores reales

# 4. Verificar configuraci√≥n autom√°ticamente
source scripts/load-env.sh

# 5. Verificar conectividad Azure
az account show
az acr list --query "[].{Name:name,LoginServer:loginServer}" -o table
```

### Paso 2: Construir y Subir Im√°genes Docker

```bash
# 1. Ejecutar el script de build y push (carga autom√°ticamente .env)
./scripts/build-and-push.sh

# El script ejecutar√° autom√°ticamente:
# - Carga de variables desde .env
# - Validaci√≥n de configuraci√≥n
# - Verificaci√≥n de prerequisitos
# - Login a ACR
# - Build de imagen backend
# - Build de imagen frontend  
# - Push de ambas im√°genes
# - Verificaci√≥n en registry
```

**Salida esperada:**
```
üèóÔ∏è Azure Day 2 Engine - Docker Build and Push
==================================================
‚úÖ Prerequisites verified
‚úÖ Logged in to ACR: advaks
‚úÖ Backend image built: advaks.azurecr.io/azure-day2-engine-backend:latest
‚úÖ Frontend image built: advaks.azurecr.io/azure-day2-engine-frontend:latest
‚úÖ Backend image pushed to registry
‚úÖ Frontend image pushed to registry
‚úÖ Build and push completed successfully!
```

### Paso 3: Desplegar a AKS con Helm

```bash
# 1. Ejecutar el script de deployment con Helm (carga autom√°ticamente .env)
./scripts/deploy-to-aks.sh

# El script ejecutar√° autom√°ticamente:
# - Carga y validaci√≥n de variables desde .env
# - Verificaci√≥n de prerequisitos (kubectl, Helm, Azure CLI)
# - Configuraci√≥n de kubectl con AKS
# - Creaci√≥n/verificaci√≥n del namespace
# - Preparaci√≥n autom√°tica de valores de Helm
# - Instalaci√≥n/actualizaci√≥n del Helm chart
# - Verificaci√≥n de deployments
```

**Salida esperada:**
```
üöÄ Azure Day 2 Engine - AKS Deployment (Helm)
==============================================
‚úÖ Prerequisites verified
‚úÖ AKS credentials configured
‚úÖ Connected to AKS cluster: adv_aks
‚úÖ Namespace 'default' ready
‚úÖ Azure credentials configured for Helm deployment
‚úÖ Helm release installed successfully
‚úÖ All deployments are ready!
```

### Paso 4: Verificar el Despliegue

```bash
# 1. Verificar el release de Helm
helm list -n default

# 2. Ver status detallado del release
helm status azure-day2-engine -n default

# 3. Verificar pods
kubectl get pods -l app.kubernetes.io/name=azure-day2-engine

# 4. Verificar servicios
kubectl get services -l app.kubernetes.io/name=azure-day2-engine

# 5. Verificar deployments
kubectl get deployments -l app.kubernetes.io/name=azure-day2-engine

# 6. Obtener IP externa del frontend
kubectl get service azure-day2-engine-frontend-service

# 7. Ver logs del backend
kubectl logs -l app.kubernetes.io/name=azure-day2-engine,component=backend

# 8. Ver logs del frontend
kubectl logs -l app.kubernetes.io/name=azure-day2-engine,component=frontend
```

### Paso 5: Probar la Aplicaci√≥n

```bash
# 1. Test de salud del backend (port-forward temporal)
kubectl port-forward service/azure-day2-engine-backend-service 8080:80 &
curl http://localhost:8080/health

# 2. Acceder al frontend via IP externa
# Esperar a que se asigne la IP externa (puede tomar 2-5 minutos)
kubectl get service azure-day2-engine-frontend-service -w

# 3. Una vez asignada, acceder via navegador
# http://<EXTERNAL-IP>/
```

## üõ†Ô∏è Configuraci√≥n Avanzada con Helm

### Personalizar Valores de Helm

Crear un archivo `custom-values.yaml` para personalizaci√≥n:

```yaml
# custom-values.yaml
backend:
  replicaCount: 2  # Cambiar a m√°s r√©plicas si es necesario
  resources:
    requests:
      memory: "512Mi"
      cpu: "500m"
    limits:
      memory: "1Gi"
      cpu: "1000m"

frontend:
  replicaCount: 1
  service:
    type: LoadBalancer  # o NodePort, ClusterIP

global:
  registry: "your-acr.azurecr.io"
  imageTag: "v1.0.0"
  azure:
    clientId: "your-real-client-id"
    tenantId: "your-real-tenant-id"
    clientSecret: "your-real-secret"
    subscriptionId: "your-real-subscription"
```

Aplicar la configuraci√≥n personalizada:
```bash
helm upgrade azure-day2-engine ./helm-chart -n default -f custom-values.yaml
```

### Scaling con Helm

```bash
# Escalar backend usando Helm
helm upgrade azure-day2-engine ./helm-chart -n default \
  --set backend.replicaCount=3

# Actualizar recursos usando Helm
helm upgrade azure-day2-engine ./helm-chart -n default \
  --set backend.resources.requests.cpu=500m \
  --set backend.resources.limits.memory=1Gi

# Configurar auto-scaling (despu√©s del deployment)
kubectl autoscale deployment azure-day2-engine-backend --cpu-percent=70 --min=1 --max=5
```

### Monitoreo y Logging con Helm

```bash
# Ver status del Helm release
helm status azure-day2-engine -n default

# Ver historial de releases
helm history azure-day2-engine -n default

# Ver logs en tiempo real
kubectl logs -f deployment/azure-day2-engine-backend

# Describir pod para troubleshooting
kubectl describe pod <pod-name>

# Verificar events del namespace
kubectl events --sort-by=.metadata.creationTimestamp

# Usar el script de operaciones
./scripts/aks-operations.sh status
./scripts/aks-operations.sh logs
./scripts/aks-operations.sh helm-status
```

## üîß Troubleshooting

### Problemas Comunes

#### 1. ImagePullBackOff
```bash
# Verificar que las im√°genes existen en ACR
az acr repository list --name $ACR_NAME

# Verificar permisos de AKS en ACR
az aks check-acr --resource-group $AKS_RESOURCE_GROUP --name $AKS_CLUSTER --acr $ACR_NAME.azurecr.io
```

#### 2. Backend no responde
```bash
# Verificar configuraci√≥n de secrets
kubectl get secret azure-credentials -o yaml

# Verificar variables de entorno en pods
kubectl exec deployment/azure-day2-engine-backend -- env | grep AZURE

# Verificar logs detallados
kubectl logs deployment/azure-day2-engine-backend --previous
```

#### 3. Frontend no accesible
```bash
# Verificar estado del LoadBalancer
kubectl describe service azure-day2-engine-frontend-service

# Verificar si el frontend puede conectar al backend
kubectl exec deployment/azure-day2-engine-frontend -- curl -I azure-day2-engine-backend-service
```

#### 4. Problemas de Azure Credentials
```bash
# Verificar configuraci√≥n actual
source scripts/load-env.sh

# Actualizar credenciales en .env
nano .env  # Editar las credenciales incorrectas

# Aplicar cambios usando el script de operaciones (carga autom√°ticamente .env)
./scripts/aks-operations.sh update-secrets

# Alternativamente, usar Helm directamente despu√©s de actualizar .env
source scripts/load-env.sh
helm upgrade azure-day2-engine ./helm-chart -n $NAMESPACE \
  --set global.azure.clientId=$AZURE_CLIENT_ID \
  --set global.azure.tenantId=$AZURE_TENANT_ID \
  --set global.azure.clientSecret=$AZURE_CLIENT_SECRET \
  --set global.azure.subscriptionId=$AZURE_SUBSCRIPTION_ID
```

#### 5. Problemas de Configuraci√≥n de Variables de Entorno
```bash
# Problema: Variables no configuradas o con valores por defecto
# S√≠ntomas: "Environment validation failed" al ejecutar scripts

# Soluci√≥n 1: Usar configuraci√≥n interactiva
./scripts/setup-env.sh

# Soluci√≥n 2: Verificar y corregir .env manualmente
cat .env  # Ver configuraci√≥n actual
nano .env  # Editar valores incorrectos

# Verificar configuraci√≥n despu√©s de los cambios
source scripts/load-env.sh

# Problema: .env no existe
# S√≠ntomas: ".env file not found"

# Soluci√≥n: Crear desde template
cp .env.example .env
./scripts/setup-env.sh

# Problema: Variables enmascaradas muestran valores incorrectos
# S√≠ntomas: Credenciales tienen longitud incorrecta

# Verificar longitudes esperadas:
# - AZURE_TENANT_ID: ~36 caracteres (UUID)
# - AZURE_CLIENT_ID: ~36 caracteres (UUID) 
# - AZURE_SUBSCRIPTION_ID: ~36 caracteres (UUID)
# - AZURE_CLIENT_SECRET: variable (generalmente 40+ caracteres)
```

#### 6. Problemas con Helm
```bash
# Ver releases de Helm
helm list -n default

# Ver status detallado
helm status azure-day2-engine -n default

# Ver historial de cambios
helm history azure-day2-engine -n default

# Rollback a una versi√≥n anterior
helm rollback azure-day2-engine 1 -n default

# Verificar sintaxis del chart
helm lint ./helm-chart

# Debug del template
helm template azure-day2-engine ./helm-chart --debug
```

## üßπ Limpieza y Rollback con Helm

### Limpiar Deployment Completo
```bash
# Ejecutar script de limpieza (usa Helm uninstall)
./scripts/cleanup-deployment.sh

# O manualmente con Helm
helm uninstall azure-day2-engine -n default

# Verificar que se elimin√≥ todo
kubectl get all -l app.kubernetes.io/name=azure-day2-engine
```

### Rollback a Versi√≥n Anterior con Helm
```bash
# Ver historial de releases de Helm
helm history azure-day2-engine -n default

# Rollback a la versi√≥n anterior
helm rollback azure-day2-engine -n default

# Rollback a una versi√≥n espec√≠fica
helm rollback azure-day2-engine 2 -n default

# Verificar el rollback
helm status azure-day2-engine -n default
```

## üìä Configuraci√≥n de Producci√≥n

### Recursos Recomendados para Producci√≥n

```yaml
# Backend - Producci√≥n
resources:
  requests:
    memory: "512Mi"
    cpu: "500m"
  limits:
    memory: "1Gi"
    cpu: "1000m"

# Frontend - Producci√≥n
resources:
  requests:
    memory: "256Mi"
    cpu: "200m"
  limits:
    memory: "512Mi"
    cpu: "400m"
```

### Configuraci√≥n de Auto-scaling
```bash
# HPA para backend
kubectl autoscale deployment azure-day2-engine-backend \
  --cpu-percent=70 --min=2 --max=10

# Verificar HPA
kubectl get hpa
```

### Backup de Configuraci√≥n
```bash
# Exportar configuraci√≥n actual
kubectl get all,secrets,configmaps -l app=azure-day2-engine -o yaml > azure-day2-engine-backup.yaml
```

## üîê Seguridad

### Network Policies (Opcional)
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: azure-day2-engine-netpol
spec:
  podSelector:
    matchLabels:
      app: azure-day2-engine
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: azure-day2-engine
  egress:
  - to: []
```

### Pod Security Context
Los Dockerfiles ya incluyen usuarios no-root. Para mayor seguridad:

```yaml
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000
```

## üìà Resultados Esperados

### URLs de Acceso
- **Frontend Dashboard**: `http://<EXTERNAL-IP>/`
- **Backend API Docs**: Port-forward a `http://localhost:8080/docs`
- **Health Check**: Port-forward a `http://localhost:8080/health`

### Estructura Final en AKS con Helm
```
azure-day2-engine/ (Helm Release)
‚îú‚îÄ‚îÄ Backend Deployment (1 replica - optimizado)
‚îÇ   ‚îî‚îÄ‚îÄ Pod 1: backend-xxx-aaa
‚îú‚îÄ‚îÄ Frontend Deployment (1 replica)
‚îÇ   ‚îî‚îÄ‚îÄ Pod 1: frontend-xxx-ccc
‚îú‚îÄ‚îÄ Services
‚îÇ   ‚îú‚îÄ‚îÄ backend-service (ClusterIP)
‚îÇ   ‚îî‚îÄ‚îÄ frontend-service (LoadBalancer)
‚îú‚îÄ‚îÄ Helm Management
‚îÇ   ‚îú‚îÄ‚îÄ Release: azure-day2-engine
‚îÇ   ‚îú‚îÄ‚îÄ Chart Version: 1.0.0
‚îÇ   ‚îî‚îÄ‚îÄ Values: Configurables via upgrade
‚îî‚îÄ‚îÄ Resources
    ‚îú‚îÄ‚îÄ ServiceAccount
    ‚îú‚îÄ‚îÄ Secret (Azure credentials)
    ‚îî‚îÄ‚îÄ ConfigMap (SQL scripts)
```

## üéâ ¬°Migraci√≥n Completada con Helm y Configuraci√≥n Centralizada!

Tu Azure Day 2 Engine ahora est√° ejecut√°ndose en AKS con Helm y gesti√≥n moderna de configuraci√≥n:

### ‚úÖ **Caracter√≠sticas Implementadas**
- ‚úÖ **Backend API optimizado** (1 r√©plica configurable)
- ‚úÖ **Frontend dashboard** accesible externamente
- ‚úÖ **Gesti√≥n simplificada** con Helm Charts
- ‚úÖ **Configuraci√≥n centralizada** mediante archivos `.env`
- ‚úÖ **Validaci√≥n autom√°tica** de variables de entorno
- ‚úÖ **Scripts inteligentes** con carga autom√°tica de configuraci√≥n
- ‚úÖ **Seguridad mejorada** con enmascaramiento de credenciales
- ‚úÖ **Actualizaciones y rollbacks** sencillos
- ‚úÖ **Servicios separados** y escalables independientemente
- ‚úÖ **Monitoreo y logging** configurado

### üöÄ **Ventajas del Nuevo Sistema**

**Helm Benefits:**
- Gesti√≥n de configuraci√≥n centralizada
- Versionado de deployments
- Rollbacks autom√°ticos
- Plantillas reutilizables
- Actualizaciones incrementales

**Sistema de Variables de Entorno:**
- üéØ **√önica fuente de verdad**: Archivo `.env` centralizado
- üîí **Seguridad mejorada**: Credenciales enmascaradas en logs
- ‚ö° **Automatizaci√≥n completa**: Sin exports manuales necesarios
- üõ°Ô∏è **Validaci√≥n robusta**: Verificaci√≥n autom√°tica de configuraciones
- üìã **Experiencia mejorada**: Scripts m√°s intuitivos y f√°ciles de usar

### üîÑ **Flujo de Trabajo Simplificado**
```bash
# 1. Configuraci√≥n una sola vez
./scripts/setup-env.sh

# 2. Build y deploy sin configuraci√≥n adicional
./scripts/build-and-push.sh
./scripts/deploy-to-aks.sh

# 3. Operaciones sin exports manuales
./scripts/aks-operations.sh status
```

El backend es el componente de valor con las APIs, mientras que el frontend sirve como herramienta de demostraci√≥n y pruebas.